# Python3 program to variants of Binary Search
 
n = 8;      # array size
a = [ 2, 3, 3, 5, 5, 5, 6, 6 ];     # Sorted array
 
# Find if key is in array
# Returns: True if key belongs to array,
# False if key doesn't belong to array
def contains(low, high, key):
    ans = False;
    while (low <= high):
        mid = low + ((high - low) // 2);
        midVal = a[mid];
 
        if (midVal < key):
 
            # if mid is less than key, all elements
            # in range [low, mid] are also less
            # so we now search in [mid + 1, high]
            low = mid + 1;
         
        elif (midVal > key):
 
            # if mid is greater than key, all elements
            # in range [mid + 1, high] are also greater
            # so we now search in [low, mid - 1]
            high = mid - 1;
         
        elif (midVal == key):
 
            # comparison added just for the sake
            # of clarity if mid is equal to key, we
            # have found that key exists in array
            ans = True;
            break;
         
    return ans;
 
 
# Find first occurrence index of key in array
# Returns: an index in range [0, n-1] if key belongs
#          to array, -1 if key doesn't belong to array
 
def first(low, high, key):
     
    ans = -1;
 
    while (low <= high):
        mid = low + ((high - low + 1) // 2);
        midVal = a[mid];
 
        if (midVal < key):
 
            # if mid is less than key, all elements
            # in range [low, mid] are also less
            # so we now search in [mid + 1, high]
            low = mid + 1;
         
        elif (midVal > key):
 
            # if mid is greater than key, all elements
            # in range [mid + 1, high] are also greater
            # so we now search in [low, mid - 1]
            high = mid - 1;
         
        elif (midVal == key):
 
            # if mid is equal to key, we note down
            #  the last found index then we search
            # for more in left side of mid
            # so we now search in [low, mid - 1]
            ans = mid;
            high = mid - 1;
 
    return ans;
 
 
# Find last occurrence index of key in array
# Returns: an index in range [0, n-1] if key
# belongs to array,
#          -1 if key doesn't belong to array
 
def last(low, high, key):
    ans = -1;
 
    while (low <= high):
        mid = low + ((high - low + 1) // 2);
        midVal = a[mid];
 
        if (midVal < key):
 
            # if mid is less than key, then all elements
            # in range [low, mid - 1] are also less
            # so we now search in [mid + 1, high]
            low = mid + 1;
         
        elif (midVal > key):
 
            # if mid is greater than key, then all
            # elements in range [mid + 1, high] are
            # also greater so we now search in
            # [low, mid - 1]
            high = mid - 1;
         
        elif (midVal == key):
 
            # if mid is equal to key, we note down
            # the last found index then we search
            # for more in right side of mid
            # so we now search in [mid + 1, high]
            ans = mid;
            low = mid + 1;
     
    return ans;
 
 
# Find index of first occurrence of least element
# greater than key in array
# Returns: an index in range [0, n-1] if key is not
# the greatest element in array,
# -1 if key is the greatest element in array */
def leastgreater(low, high, key):
    ans = -1;
 
    while (low <= high):
        mid = low + ((high - low + 1) // 2);
        midVal = a[mid];
 
        if (midVal < key):
 
            # if mid is less than key, all elements
            # in range [low, mid - 1] are <= key
            # then we search in right side of mid
            # so we now search in [mid + 1, high]
            low = mid + 1;
         
        elif (midVal > key) :
 
            # if mid is greater than key, all elements
            # in range [mid + 1, high] are >= key
            # we note down the last found index, then
            # we search in left side of mid
            # so we now search in [low, mid - 1]
            ans = mid;
            high = mid - 1;
         
        elif (midVal == key) :
 
            # if mid is equal to key, all elements in
            # range [low, mid] are <= key
            # so we now search in [mid + 1, high]
            low = mid + 1;
 
    return ans;
 
 
# Find index of last occurrence of greatest element
# less than key in array
# Returns: an index in range [0, n-1] if key is not
# the least element in array,
# -1 if key is the least element in array */
def greatestlesser(low, high, key):
    ans = -1;
 
    while (low <= high):
        mid = low + ((high - low + 1) // 2);
        midVal = a[mid];
 
        if (midVal < key):
 
            # if mid is less than key, all elements
            # in range [low, mid - 1] are < key
            # we note down the last found index, then
            # we search in right side of mid
            # so we now search in [mid + 1, high]
            ans = mid;
            low = mid + 1;
         
        elif (midVal > key):
 
            # if mid is greater than key, all elements
            # in range [mid + 1, high] are > key
            # then we search in left side of mid
            # so we now search in [low, mid - 1]
            high = mid - 1;
         
        elif (midVal == key) :
 
            # if mid is equal to key, all elements
            # in range [mid + 1, high] are >= key
            # then we search in left side of mid
            # so we now search in [low, mid - 1]
            high = mid - 1;
         
    return ans;
 
 
print("Contains");
 
for i in range(10):
    print(i, contains(0, n - 1, i));
 
print("First occurrence of key");
for i in range(10):
    print(i, first(0, n - 1, i));
 
print("Last occurrence of key");
for i in range(10):
    print(i, last(0, n - 1, i));
 
 
print("Least integer greater than key");
for i in range(10):
    print(i, leastgreater(0, n - 1, i));
 
 
print("Greatest integer lesser than key");
for i in range(10):
    print(i, greatestlesser(0, n - 1, i));
 
 
 
# This code is contributed by phasing17




# If the target exists, returns its leftmost index.
# Else, returns the index of where it should be.
def binarySearch(nums: List[int], target: int) -> int:
    l, r = 0, len(nums)
    while l < r :
        m = (l + r) // 2;
        if nums[m] < target:
            l = m + 1;
        else: 
            r = m;
    return l;

nums = [1, 2, 3, 3, 3, 6, 9];

# target exists
# returns the leftmost index

print("nums = " + str(nums))
print("=== target exists ===");
exists = [1,2,3,6,9]
for i in exists:
    print("index of " + str(i) + " = " + str(binarySearch(nums, i)));

# target does not exist
# returns the index of where the it should be
print("=== target does not exist: index of where it should be ===");
not_exists = [0, -100, 4, 10, 100]
for i in not_exists:
    print("index of " + str(i) + " = " + str(binarySearch(nums, i)));

# verify target exists
print("=== verify target exists ===");
verify = [1,3,0,7,10]
for i in verify:
    index = binarySearch(nums, i)
    contains = index < len(nums) and i == nums[index]
    print("nums contains " + str(i) + ": " + str(contains))




# Binary Tree Traversals
class TreeNode:
def stringToIntegerList(input):
    return json.loads(input)

    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def preorder(root: TreeNode):
    if not root: return
    print(root.val, end = " ")
    inorder(root.left)
    inorder(root.right)

def inorder(root: TreeNode):
    if not root: return
    inorder(root.left)
    print(root.val, end = " ")
    inorder(root.right)
    
def postorder(root: TreeNode):
    if not root: return
    postorder(root.left)
    postorder(root.right)
    print(root.val, end = " ")
    
def levelorder(root: TreeNode):
    if not root: return
    q = deque([root])
    while q:
        size = len(q)
        for i in range(size):
            node = q.popleft()
            print(str(node.val), end = " ")
            if node.left: q.append(node.left)
            if node.right: q.append(node.right)
        print("")

"""
           5
          / \
         3   7
        / \   \
       1   4   9
"""
        
root = TreeNode(5, TreeNode(3, TreeNode(1), TreeNode(4)), TreeNode(7, None, TreeNode(9)))
print("preorder: ", end = "")
preorder(root)
print("\ninorder: ", end = "")
inorder(root)
print("\npostorder: ", end = "")
postorder(root)
print("\nlevelorder: ")
levelorder(root)


