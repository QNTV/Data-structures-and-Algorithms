# Python3 program to variants of Binary Search
 
n = 8;      # array size
a = [ 2, 3, 3, 5, 5, 5, 6, 6 ];     # Sorted array
 
# Find if key is in array
# Returns: True if key belongs to array,
# False if key doesn't belong to array
def contains(low, high, key):
    ans = False;
    while (low <= high):
        mid = low + ((high - low) // 2);
        midVal = a[mid];
 
        if (midVal < key):
 
            # if mid is less than key, all elements
            # in range [low, mid] are also less
            # so we now search in [mid + 1, high]
            low = mid + 1;
         
        elif (midVal > key):
 
            # if mid is greater than key, all elements
            # in range [mid + 1, high] are also greater
            # so we now search in [low, mid - 1]
            high = mid - 1;
         
        elif (midVal == key):
 
            # comparison added just for the sake
            # of clarity if mid is equal to key, we
            # have found that key exists in array
            ans = True;
            break;
         
    return ans;
 
 
# Find first occurrence index of key in array
# Returns: an index in range [0, n-1] if key belongs
#          to array, -1 if key doesn't belong to array
 
def first(low, high, key):
     
    ans = -1;
 
    while (low <= high):
        mid = low + ((high - low + 1) // 2);
        midVal = a[mid];
 
        if (midVal < key):
 
            # if mid is less than key, all elements
            # in range [low, mid] are also less
            # so we now search in [mid + 1, high]
            low = mid + 1;
         
        elif (midVal > key):
 
            # if mid is greater than key, all elements
            # in range [mid + 1, high] are also greater
            # so we now search in [low, mid - 1]
            high = mid - 1;
         
        elif (midVal == key):
 
            # if mid is equal to key, we note down
            #  the last found index then we search
            # for more in left side of mid
            # so we now search in [low, mid - 1]
            ans = mid;
            high = mid - 1;
 
    return ans;
 
 
# Find last occurrence index of key in array
# Returns: an index in range [0, n-1] if key
# belongs to array,
#          -1 if key doesn't belong to array
 
def last(low, high, key):
    ans = -1;
 
    while (low <= high):
        mid = low + ((high - low + 1) // 2);
        midVal = a[mid];
 
        if (midVal < key):
 
            # if mid is less than key, then all elements
            # in range [low, mid - 1] are also less
            # so we now search in [mid + 1, high]
            low = mid + 1;
         
        elif (midVal > key):
 
            # if mid is greater than key, then all
            # elements in range [mid + 1, high] are
            # also greater so we now search in
            # [low, mid - 1]
            high = mid - 1;
         
        elif (midVal == key):
 
            # if mid is equal to key, we note down
            # the last found index then we search
            # for more in right side of mid
            # so we now search in [mid + 1, high]
            ans = mid;
            low = mid + 1;
     
    return ans;
 
 
# Find index of first occurrence of least element
# greater than key in array
# Returns: an index in range [0, n-1] if key is not
# the greatest element in array,
# -1 if key is the greatest element in array */
def leastgreater(low, high, key):
    ans = -1;
 
    while (low <= high):
        mid = low + ((high - low + 1) // 2);
        midVal = a[mid];
 
        if (midVal < key):
 
            # if mid is less than key, all elements
            # in range [low, mid - 1] are <= key
            # then we search in right side of mid
            # so we now search in [mid + 1, high]
            low = mid + 1;
         
        elif (midVal > key) :
 
            # if mid is greater than key, all elements
            # in range [mid + 1, high] are >= key
            # we note down the last found index, then
            # we search in left side of mid
            # so we now search in [low, mid - 1]
            ans = mid;
            high = mid - 1;
         
        elif (midVal == key) :
 
            # if mid is equal to key, all elements in
            # range [low, mid] are <= key
            # so we now search in [mid + 1, high]
            low = mid + 1;
 
    return ans;
 
 
# Find index of last occurrence of greatest element
# less than key in array
# Returns: an index in range [0, n-1] if key is not
# the least element in array,
# -1 if key is the least element in array */
def greatestlesser(low, high, key):
    ans = -1;
 
    while (low <= high):
        mid = low + ((high - low + 1) // 2);
        midVal = a[mid];
 
        if (midVal < key):
 
            # if mid is less than key, all elements
            # in range [low, mid - 1] are < key
            # we note down the last found index, then
            # we search in right side of mid
            # so we now search in [mid + 1, high]
            ans = mid;
            low = mid + 1;
         
        elif (midVal > key):
 
            # if mid is greater than key, all elements
            # in range [mid + 1, high] are > key
            # then we search in left side of mid
            # so we now search in [low, mid - 1]
            high = mid - 1;
         
        elif (midVal == key) :
 
            # if mid is equal to key, all elements
            # in range [mid + 1, high] are >= key
            # then we search in left side of mid
            # so we now search in [low, mid - 1]
            high = mid - 1;
         
    return ans;
 
 
print("Contains");
 
for i in range(10):
    print(i, contains(0, n - 1, i));
 
print("First occurrence of key");
for i in range(10):
    print(i, first(0, n - 1, i));
 
print("Last occurrence of key");
for i in range(10):
    print(i, last(0, n - 1, i));
 
 
print("Least integer greater than key");
for i in range(10):
    print(i, leastgreater(0, n - 1, i));
 
 
print("Greatest integer lesser than key");
for i in range(10):
    print(i, greatestlesser(0, n - 1, i));
 
 
 
# This code is contributed by phasing17




# If the target exists, returns its leftmost index.
# Else, returns the index of where it should be.
def binarySearch(nums: List[int], target: int) -> int:
    l, r = 0, len(nums)
    while l < r :
        m = (l + r) // 2;
        if nums[m] < target:
            l = m + 1;
        else: 
            r = m;
    return l;

nums = [1, 2, 3, 3, 3, 6, 9];

# target exists
# returns the leftmost index

print("nums = " + str(nums))
print("=== target exists ===");
exists = [1,2,3,6,9]
for i in exists:
    print("index of " + str(i) + " = " + str(binarySearch(nums, i)));

# target does not exist
# returns the index of where the it should be
print("=== target does not exist: index of where it should be ===");
not_exists = [0, -100, 4, 10, 100]
for i in not_exists:
    print("index of " + str(i) + " = " + str(binarySearch(nums, i)));

# verify target exists
print("=== verify target exists ===");
verify = [1,3,0,7,10]
for i in verify:
    index = binarySearch(nums, i)
    contains = index < len(nums) and i == nums[index]
    print("nums contains " + str(i) + ": " + str(contains))




# Binary Tree Traversals
class TreeNode:
def stringToIntegerList(input):
    return json.loads(input)

    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def preorder(root: TreeNode):
    if not root: return
    print(root.val, end = " ")
    inorder(root.left)
    inorder(root.right)

def inorder(root: TreeNode):
    if not root: return
    inorder(root.left)
    print(root.val, end = " ")
    inorder(root.right)
    
def postorder(root: TreeNode):
    if not root: return
    postorder(root.left)
    postorder(root.right)
    print(root.val, end = " ")
    
def levelorder(root: TreeNode):
    if not root: return
    q = deque([root])
    while q:
        size = len(q)
        for i in range(size):
            node = q.popleft()
            print(str(node.val), end = " ")
            if node.left: q.append(node.left)
            if node.right: q.append(node.right)
        print("")

"""
           5
          / \
         3   7
        / \   \
       1   4   9
"""
        
root = TreeNode(5, TreeNode(3, TreeNode(1), TreeNode(4)), TreeNode(7, None, TreeNode(9)))
print("preorder: ", end = "")
preorder(root)
print("\ninorder: ", end = "")
inorder(root)
print("\npostorder: ", end = "")
postorder(root)
print("\nlevelorder: ")
levelorder(root)


# Binary Search tutorial (C++ and Python) https://www.youtube.com/watch?v=GU7DpgHINWQ&t=796s

# Implementation
L, R = o, N-1
while L <= R:
    mid = L ( R - L) // 2
    if a[mid] == target:
        return mid
    if a[mid] < target:
        L = mid + 1
    else:
        R = mid - 1
return -1


# Template #1 is the most basic and elementary form of Binary Search. It is the standard Binary Search Template that most high schools or universities use when they first teach students computer science. Template #1 is used to search for an element or condition which can be determined by accessing a single index in the array.

 

# Key Attributes:

# Most basic and elementary form of Binary Search
# Search Condition can be determined without comparing to the element's neighbors (or use specific elements around it)
# No post-processing required because at each step, you are checking to see if the element has been found. If you reach the end, then you know the element is not found
 

# Distinguishing Syntax:

# Initial Condition: left = 0, right = length-1
# Termination: left > right
# Searching Left: right = mid-1
# Searching Right: left = mid+1


def binarySearch(nums, target):
    """
    :type nums: List[int]
    :type target: int
    :rtype: int
    """
    if len(nums) == 0:
        return -1

    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    # End Condition: left > right
    return -1



# Template #2 is an advanced form of Binary Search. It is used to search for an element or condition which requires accessing the current index and its immediate right neighbor's index in the array.

 

# Key Attributes:

# An advanced way to implement Binary Search.
# Search Condition needs to access the element's immediate right neighbor
# Use the element's right neighbor to determine if the condition is met and decide whether to go left or right
# Guarantees Search Space is at least 2 in size at each step
# Post-processing required. Loop/Recursion ends when you have 1 element left. Need to assess if the remaining element meets the condition.
 

# Distinguishing Syntax:

# Initial Condition: left = 0, right = length
# Termination: left == right
# Searching Left: right = mid
# Searching Right: left = mid+1

def binarySearch(nums, target):
    """
    :type nums: List[int]
    :type target: int
    :rtype: int
    """
    if len(nums) == 0:
        return -1

    left, right = 0, len(nums)
    while left < right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid

    # Post-processing:
    # End Condition: left == right
    if left != len(nums) and nums[left] == target:
        return left
    return -1




# Template #3 is another unique form of Binary Search. It is used to search for an element or condition which requires accessing the current index and its immediate left and right neighbor's index in the array.

 

# Key Attributes:

# An alternative way to implement Binary Search
# Search Condition needs to access element's immediate left and right neighbors
# Use element's neighbors to determine if condition is met and decide whether to go left or right
# Gurantees Search Space is at least 3 in size at each step
# Post-processing required. Loop/Recursion ends when you have 2 elements left. Need to assess if the remaining elements meet the condition.
 

# Distinguishing Syntax:

# Initial Condition: left = 0, right = length-1
# Termination: left + 1 == right
# Searching Left: right = mid
# Searching Right: left = mid

def binarySearch(nums, target):
    """
    :type nums: List[int]
    :type target: int
    :rtype: int
    """
    if len(nums) == 0:
        return -1

    left, right = 0, len(nums) - 1
    while left + 1 < right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid
        else:
            right = mid

    # Post-processing:
    # End Condition: left + 1 == right
    if nums[left] == target: return left
    if nums[right] == target: return right
    return -1




    Generalized Binary Search
#704 https://leetcode.com/problems/binary-search/
Left, right are possible search spaces, we need to check l,r when they exist in array [0, n-1]

public int search(int[] nums, int target) {
        int left = 0 ;         int right = nums.length -1;
        while (left < right) {            
            int mid = left + (right-left)/2;            
            if(nums[mid] < target) {
                left = mid + 1;
            }
            else right = mid;
        }
        if(nums[left] == target)
            return left;
        return -1;
    }
This is another variant to move right index instead of left.

    public int search(int[] nums, int target) {
        int left = 0 ;         int right = nums.length - 1;
        while(left < right) {
            int mid = left + (right-left+1)/2;            <<<< Mid biased to support updating right
            if(nums[mid] > target) {
                right = mid - 1;
            }
            else left = mid;
        }
        if(nums[left] == target)
            return left;
        return -1;
    }
#35 https://leetcode.com/problems/search-insert-position/
It is possible to insert after len – 1, so right is len here instead.

public int searchInsert(int[] nums, int target) {
        int left = 0 ;         int right = nums.length;
        while (left < right) {            
            int mid = left + (right-left)/2;            
            if(nums[mid] < target) {
                left = mid + 1;
            }
            else right = mid;
        }
        return left;
    }
#69 https://leetcode.com/problems/sqrtx/
#367 https://leetcode.com/problems/valid-perfect-square/

    public int mySqrt(int x) {
        if(x == 0 || x == 1)
            return x;
        int left = 1; 
        int right = x/2 +2;
        
        while (left < right) {            
            int mid = left + (right-left+1)/2;            
            if (mid > x/mid) {
                right = mid - 1;
            }
            else left = mid;
        }        
        return left;
    }
#278 https://leetcode.com/problems/first-bad-version/
#374 https://leetcode.com/problems/guess-number-higher-or-lower/

    public int guessNumber(int n) {
        int left = 1 ; 
        int right = n;
        while (left < right) {            
            int mid = left + (right-left)/2;            
            if(guess(mid) == 1) {
                left = mid + 1;
            }
            else right = mid;
        }
        
        return left;
    }
#162 https://leetcode.com/problems/find-peak-element/

  public int findPeakElement(int[] nums) {
        int left = 0 ; 
        int right = nums.length - 1;
        while (left < right) {            
            int mid = left + (right-left)/2;            
            if(nums[mid+1] > nums[mid]) {
                left = mid + 1;
            }
            else right = mid;
        }
        
        return left;
    }
#153 https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/

public int findMin(int[] nums) {
        int left = 0 ; 
        int right = nums.length - 1;
        while (left < right) {            
            int mid = left + (right-left)/2;            
            if(nums[mid] > nums[right]) {
                left = mid + 1;
            }
            else right = mid;
        }
        
        return nums[left];
    }
#34 Search Range (First & Last occurrences)

public int searchFirst(int[] nums, int target) {
        int left = 0 ; 
        int right = nums.length -1;
        while (left < right) {            
            int mid = left + (right-left)/2;  
            
            if(nums[mid] < target) {
                left = mid + 1;
            }
            else right = mid;
        }
        if(nums.length > 0 && nums[left] == target)
            return left;
        return -1;
    }
    public int searchLast(int[] nums, int target) {
        int left = 0 ; 
        int right = nums.length -1;
        while (left < right) {            
            int mid = left + (right-left+1)/2;            <<<< Mid biased to support updating right instead
            if(nums[mid] > target) {
                right = mid - 1;
            }
            else {
                left = mid;
            }
        }
        if(nums.length > 0 && nums[left] == target)
            return left;
        return -1;
    }
#410 https://leetcode.com/problems/split-array-largest-sum/
#1011 https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/

public int shipWithinDays(int[] weights, int days) {
        int left = weights[0]; 
        int right = 0;
        for(int e: weights) {
            left = Math.max(left, e); 
            right += e;
        }
        
        while(left<right) {
            int mid = left+(right-left) / 2;
            if(isPossible(days, mid, weights)) {
                right = mid;
            }
            else {
                left = mid +1;
            }
        }
        return left;
    }
    
    private boolean isPossible(int days, int capacity, int[] wt) {
        int d = 0; 
        int curr = 0 ; 
        for(int w : wt) {
            curr+= w;
            if(curr > capacity) {
                curr = w; 
                d++;
                if(d == days)
                    return false;
            }
        }
        return true;
    }